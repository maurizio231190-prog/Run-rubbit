<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Porcellino HORROR • MEME PANICORE</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#000; overflow:hidden; touch-action:manipulation; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  // ------------------------------------------------------------
  // PORCELLINO + PIU' HORROR MEME PANICORE ASSURDO
  // NO GORE: solo vibe spooky-cartoon + glitch + clown "BOO" meme.
  // Struttura: runner con buchi (game over se cadi), items che scorrono.
  // ------------------------------------------------------------

  // ---------- Canvas ----------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // polyfill roundRect (se manca)
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize, { passive:true });
  resize();

  // ---------- ASSETS (opzionali) ----------
  const ASSETS = {
    bgSrc:    "assets/bg_horror.jpg",     // opzionale
    worldSrc: "assets/world_horror.png",  // opzionale
    memeSrc:  "assets/meme_horror.png",   // opzionale

    bongSrc:  "assets/bong.png",          // bonus
    cuffsSrc: "assets/cuffs.png",         // bonus
    clownSrc: "assets/clown.png",         // penalità (boo)
  };

  function loadImage(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = src;
    });
  }

  const IMAGES = { bg:null, world:null, meme:null, bong:null, cuffs:null, clown:null };

  function drawImageCover(img, alpha=1) {
    const w = innerWidth, h = innerHeight;
    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;
    const s = Math.max(w / iw, h / ih);
    const dw = iw * s;
    const dh = ih * s;
    const dx = (w - dw) / 2;
    const dy = (h - dh) / 2;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.drawImage(img, dx, dy, dw, dh);
    ctx.restore();
  }

  // ---------- Audio ----------
  let audioCtx = null;
  function beep(freq=440, dur=0.05, type="sine", gain=0.03) {
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + dur);
    } catch(e) {}
  }
  function booChord() {
    // accordino "spooky" ma breve (no jump-scare forte)
    beep(196, 0.08, "sine", 0.025);
    setTimeout(()=>beep(233, 0.08, "triangle", 0.022), 40);
    setTimeout(()=>beep(174, 0.10, "sawtooth", 0.018), 70);
  }

  // ---------- World ----------
  const W = () => innerWidth;
  const H = () => innerHeight;

  const world = {
    state: "ready",
    t: 0,
    score: 0,
    best: Number(localStorage.getItem("pig_best") || 0),

    speed: 320,
    spawnMin: 0.78,
    spawnMax: 1.35,
    nextSpawn: 1.0,
    groundY: () => Math.round(H()*0.78),

    holes: [],
    nextHoleX: 0,

    // meme panicore layer
    sparks: [],
    doodles: [],
    eyes: [],
    doodleTimer: 0,
    sparkTimer: 0,
    eyeTimer: 0,

    // horror fx
    shake: 0,
    glitch: 0,
    invert: 0,
    fog: 0,
  };

  // ---------- Style helpers ----------
  function doodleStroke() {
    ctx.lineWidth = Math.max(3, Math.round(Math.min(W(),H()) * 0.0045));
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = "#000";
    ctx.fillStyle = "#fff";
  }

  function rand(a,b){ return a + Math.random()*(b-a); }

  // ---------- Pig ----------
  const pig = {
    x: () => Math.round(W()*0.22),
    y: 0,
    vy: 0,
    r: () => Math.round(Math.min(W(),H())*0.055),
    onGround: true,
  };

  function reset() {
    world.state = "ready";
    world.t = 0;
    world.score = 0;
    world.speed = 320;
    world.nextSpawn = rand(world.spawnMin, world.spawnMax);

    items.length = 0;

    world.holes.length = 0;
    world.nextHoleX = W() + Math.max(240, W()*0.42);

    pig.y = world.groundY() - pig.r();
    pig.vy = 0;
    pig.onGround = true;

    world.sparks.length = 0;
    world.doodles.length = 0;
    world.eyes.length = 0;
    world.doodleTimer = 0.22;
    world.sparkTimer = 0.07;
    world.eyeTimer = 0.45;

    world.shake = 0;
    world.glitch = 0;
    world.invert = 0;
    world.fog = 0.18;
  }

  // ---------- Items ----------
  const items = [];
  // bong/cuffs = bonus ; clown = "boo" penalità
  const TYPES = ["bong","cuffs","clown"];

  function spawnItem() {
    const r = Math.round(Math.min(W(),H())*0.045);

    // più horror: clown un po' più presente, ma non troppo
    const p = Math.random();
    const type = (p < 0.42) ? "bong" : (p < 0.78) ? "cuffs" : "clown";

    const gy = world.groundY();
    const yMin = gy - r*5.2;
    const yMax = gy - r*2.4;

    items.push({
      type,
      r,
      x: W() + r + 10,
      y: Math.max(r+10, rand(yMin, yMax)),
      vx: -world.speed,
      hit: false,
    });
  }

  // ---- Bubble + icon ----
  function drawBubbleWithIcon(x, y, r, img, bubbleFill, fallbackDraw) {
    doodleStroke();

    // ombra
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(x + r*0.12, y + r*0.14, r*1.05, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // bubble
    ctx.fillStyle = bubbleFill;
    ctx.beginPath();
    ctx.arc(x, y, r*1.02, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = "#000";
    ctx.lineWidth = Math.max(2, ctx.lineWidth*0.65);
    ctx.stroke();

    // highlight
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(x - r*0.35, y - r*0.35, r*0.28, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    if (img) {
      const pad = r*0.35;
      const box = r*2 - pad;
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;
      const s = Math.min(box / iw, box / ih);
      const dw = iw * s;
      const dh = ih * s;
      ctx.drawImage(img, x - dw/2, y - dh/2, dw, dh);
    } else if (fallbackDraw) {
      fallbackDraw(x,y,r);
    } else {
      ctx.fillStyle = "#000";
      ctx.font = `900 ${Math.max(16, r*0.85)}px ui-rounded, system-ui, -apple-system, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("?", x, y);
      ctx.textAlign = "left";
      ctx.textBaseline = "alphabetic";
    }
  }

  function drawBongFallback(x,y,r){
    doodleStroke();
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle="#fff"; ctx.strokeStyle="#000";
    ctx.lineWidth = Math.max(3, Math.round(Math.min(W(),H())*0.004));
    // bottiglina assurda
    ctx.beginPath();
    ctx.roundRect(-r*0.35, -r*0.50, r*0.70, r*1.00, r*0.25);
    ctx.fill(); ctx.stroke();
    ctx.beginPath();
    ctx.roundRect(-r*0.18, -r*0.78, r*0.36, r*0.32, r*0.18);
    ctx.fill(); ctx.stroke();
    // fumo meme
    ctx.beginPath();
    ctx.moveTo(r*0.20, -r*0.70);
    ctx.bezierCurveTo(r*0.70, -r*0.95, r*0.65, -r*0.30, r*0.25, -r*0.35);
    ctx.stroke();
    ctx.restore();
  }

  function drawCuffsFallback(x,y,r){
    doodleStroke();
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle="#fff"; ctx.strokeStyle="#000";
    ctx.lineWidth = Math.max(3, Math.round(Math.min(W(),H())*0.004));
    // manette cartoon
    for (const sx of [-1,1]) {
      ctx.beginPath();
      ctx.arc(sx*r*0.28, 0, r*0.32, 0, Math.PI*2);
      ctx.fill(); ctx.stroke();
      ctx.beginPath();
      ctx.arc(sx*r*0.28, 0, r*0.18, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.moveTo(-r*0.05, 0);
    ctx.lineTo(r*0.05, 0);
    ctx.stroke();
    ctx.restore();
  }

  function drawClownFallback(x,y,r){
    doodleStroke();
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle="#fff"; ctx.strokeStyle="#000";
    ctx.lineWidth = Math.max(3, Math.round(Math.min(W(),H())*0.004));

    // faccia
    ctx.beginPath();
    ctx.arc(0, 0, r*0.62, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // occhi "boo" (cartoon)
    ctx.fillStyle="#000";
    ctx.beginPath(); ctx.arc(-r*0.20, -r*0.12, Math.max(2, r*0.08), 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( r*0.20, -r*0.12, Math.max(2, r*0.08), 0, Math.PI*2); ctx.fill();

    // naso
    ctx.fillStyle="#fff";
    ctx.beginPath(); ctx.arc(0, r*0.06, r*0.16, 0, Math.PI*2); ctx.fill(); ctx.stroke();

    // sorriso "assurdo"
    ctx.strokeStyle="#000";
    ctx.lineWidth = Math.max(2, ctx.lineWidth*0.7);
    ctx.beginPath();
    ctx.arc(0, r*0.22, r*0.30, 0.12*Math.PI, 0.88*Math.PI);
    ctx.stroke();

    // capelli puff
    ctx.fillStyle="#fff";
    for (const sx of [-1,1]) {
      ctx.beginPath();
      ctx.arc(sx*r*0.75, -r*0.02, r*0.22, 0, Math.PI*2);
      ctx.fill(); ctx.stroke();
    }

    // BOO tag
    ctx.fillStyle="#fff";
    ctx.strokeStyle="#000";
    ctx.lineWidth = Math.max(3, Math.round(Math.min(W(),H())*0.004));
    ctx.font = `900 ${Math.max(10, r*0.40)}px ui-rounded, system-ui`;
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.strokeText("BOO", 0, r*0.92);
    ctx.fillText("BOO", 0, r*0.92);
    ctx.textAlign="left"; ctx.textBaseline="alphabetic";

    ctx.restore();
  }

  function drawItem(it) {
    if (it.type === "bong")  return drawBubbleWithIcon(it.x, it.y, it.r, IMAGES.bong,  "rgba(120, 255, 210, 0.92)", drawBongFallback);
    if (it.type === "cuffs") return drawBubbleWithIcon(it.x, it.y, it.r, IMAGES.cuffs, "rgba(255, 190, 205, 0.92)", drawCuffsFallback);
    return drawBubbleWithIcon(it.x, it.y, it.r, IMAGES.clown, "rgba(210, 180, 255, 0.92)", drawClownFallback);
  }

  // ---------- Buchi ----------
  function groundUnderX(px) {
    for (const h of world.holes) {
      if (px >= h.x && px <= h.x + h.w) return false;
    }
    return true;
  }

  // buchi: intervalli più pazzi (fasi + micro-burst)
  function spawnHole() {
    const base = Math.min(W(), H());

    const wMin = Math.max(70, base*0.10);
    const wMax = Math.max(170, base*0.25);

    const phase = Math.floor(world.t / 5.2) % 4;
    let spacingMin, spacingMax;

    if (phase === 0) {             // denso
      spacingMin = Math.max(160, base*0.18);
      spacingMax = Math.max(340, base*0.38);
    } else if (phase === 1) {      // respiro
      spacingMin = Math.max(340, base*0.45);
      spacingMax = Math.max(820, base*0.86);
    } else if (phase === 2) {      // normale
      spacingMin = Math.max(240, base*0.30);
      spacingMax = Math.max(600, base*0.62);
    } else {                        // caos
      spacingMin = Math.max(130, base*0.16);
      spacingMax = Math.max(520, base*0.58);
    }

    // burst: a volte due buchi quasi attaccati (assurdo)
    if (Math.random() < 0.22) {
      spacingMin = Math.max(110, spacingMin * 0.55);
      spacingMax = Math.max(220, spacingMax * 0.65);
    }

    const w = rand(wMin, wMax);
    const x = W() + 10;

    world.holes.push({ x, w });
    world.nextHoleX = x + w + rand(spacingMin, spacingMax);
  }

  function updateHoles(dt) {
    if (world.nextHoleX <= W()) spawnHole();
    else world.nextHoleX -= world.speed * dt;

    for (const h of world.holes) h.x -= world.speed * dt;
    for (let i=world.holes.length-1; i>=0; i--) {
      if (world.holes[i].x + world.holes[i].w < -30) world.holes.splice(i,1);
    }
  }

  // ---------- MEME PANICORE HORROR LAYERS ----------
  function spawnSpark() {
    const gy = world.groundY();
    const y = rand(gy - H()*0.62, gy - H()*0.10);
    world.sparks.push({
      x: W() + 20,
      y,
      vx: -world.speed * rand(0.85, 1.35),
      vy: rand(-14, 14),
      s: rand(2, 7),
      a: rand(0.14, 0.32),
      life: rand(0.55, 1.05),
    });
  }

  function spawnDoodle() {
    const kinds = ["NOPE", "BOO!", "???", "RUN", "AHA", "LOL", "SUS", "CIRCO", "PANIC"];
    const k = kinds[(Math.random()*kinds.length)|0];
    world.doodles.push({
      k,
      x: W() + rand(0, 160),
      y: rand(H()*0.08, H()*0.52),
      vx: -world.speed * rand(0.10, 0.26),
      rot: rand(-0.40, 0.40),
      vr: rand(-0.45, 0.45),
      s: rand(18, 36),
      a: rand(0.10, 0.24),
    });
  }

  function spawnEye() {
    const gy = world.groundY();
    world.eyes.push({
      x: W() + rand(0, 220),
      y: rand(H()*0.10, gy - H()*0.22),
      vx: -world.speed * rand(0.04, 0.10),
      r: rand(6, 14),
      blink: rand(0.3, 1.2),
      a: rand(0.10, 0.22),
    });
  }

  function updateMemeWorld(dt) {
    const panic = Math.max(0, Math.min(1, (world.speed - 340) / 200));

    world.sparkTimer -= dt * (1 + panic*2.0);
    if (world.sparkTimer <= 0) {
      spawnSpark();
      world.sparkTimer = rand(0.045, 0.10);
    }

    world.doodleTimer -= dt * (1 + panic*1.4);
    if (world.doodleTimer <= 0) {
      spawnDoodle();
      world.doodleTimer = rand(0.35, 0.85);
    }

    world.eyeTimer -= dt * (1 + panic*0.6);
    if (world.eyeTimer <= 0) {
      spawnEye();
      world.eyeTimer = rand(0.35, 0.85);
    }

    for (const p of world.sparks) {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
    }
    for (let i=world.sparks.length-1; i>=0; i--) {
      if (world.sparks[i].x < -60 || world.sparks[i].life <= 0) world.sparks.splice(i,1);
    }

    for (const d of world.doodles) {
      d.x += d.vx * dt;
      d.rot += d.vr * dt;
    }
    for (let i=world.doodles.length-1; i>=0; i--) {
      if (world.doodles[i].x < -120) world.doodles.splice(i,1);
    }

    for (const e of world.eyes) {
      e.x += e.vx * dt;
      e.blink -= dt;
      if (e.blink <= 0) e.blink = rand(0.6, 1.6);
    }
    for (let i=world.eyes.length-1; i>=0; i--) {
      if (world.eyes[i].x < -120) world.eyes.splice(i,1);
    }
  }

  function drawMemeWorldLayers() {
    // overlay world
    if (IMAGES.world) drawImageCover(IMAGES.world, 0.22);

    const panic = Math.max(0, Math.min(1, (world.speed - 340) / 200));
    const glitch = Math.max(0, Math.min(1, world.glitch / 0.22));

    // vignette horror
    ctx.save();
    ctx.globalAlpha = 0.55 + panic*0.25;
    const v = ctx.createRadialGradient(W()*0.35, H()*0.35, 10, W()*0.35, H()*0.35, Math.max(W(),H())*0.95);
    v.addColorStop(0, "rgba(0,0,0,0)");
    v.addColorStop(0.6, "rgba(0,0,0,0.18)");
    v.addColorStop(1, "rgba(0,0,0,0.62)");
    ctx.fillStyle = v;
    ctx.fillRect(0,0,W(),H());
    ctx.restore();

    // glow viola/rosa "panicore"
    ctx.save();
    ctx.globalAlpha = (0.18 + panic*0.22) * (1 - glitch*0.4);
    const g = ctx.createRadialGradient(W()*0.22, H()*0.35, 10, W()*0.22, H()*0.35, Math.max(W(),H())*0.95);
    g.addColorStop(0, "rgba(190, 120, 255, 0.55)");
    g.addColorStop(0.5, "rgba(255, 80, 120, 0.14)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W(),H());
    ctx.restore();

    // sparks
    ctx.save();
    for (const p of world.sparks) {
      ctx.globalAlpha = p.a * Math.max(0, Math.min(1, p.life));
      ctx.fillStyle = "#fff";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = Math.max(2, Math.round(Math.min(W(),H())*0.0028));
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.s, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.globalAlpha *= 0.55;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x + p.s*2.4, p.y + p.s*0.15);
      ctx.stroke();
    }
    ctx.restore();

    // eyes in darkness (cartoon)
    ctx.save();
    for (const e of world.eyes) {
      const closed = (e.blink < 0.10);
      ctx.globalAlpha = e.a;
      ctx.fillStyle = "#fff";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = Math.max(2, Math.round(Math.min(W(),H())*0.0025));
      if (!closed) {
        ctx.beginPath(); ctx.ellipse(e.x, e.y, e.r*1.25, e.r*0.85, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "#000";
        ctx.beginPath(); ctx.arc(e.x + Math.sin(world.t*3 + e.y)*e.r*0.20, e.y, Math.max(2, e.r*0.28), 0, Math.PI*2); ctx.fill();
      } else {
        ctx.beginPath(); ctx.moveTo(e.x - e.r*1.2, e.y); ctx.lineTo(e.x + e.r*1.2, e.y); ctx.stroke();
      }
    }
    ctx.restore();

    // doodle texts
    ctx.save();
    doodleStroke();
    for (const d of world.doodles) {
      ctx.save();
      ctx.translate(d.x, d.y);
      ctx.rotate(d.rot);
      ctx.globalAlpha = d.a;
      ctx.font = `900 ${d.s}px ui-rounded, system-ui, -apple-system, sans-serif`;
      ctx.fillStyle = "#fff";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = Math.max(3, Math.round(Math.min(W(),H())*0.004));
      ctx.strokeText(d.k, 0, 0);
      ctx.fillText(d.k, 0, 0);
      ctx.restore();
    }
    ctx.restore();

    // logo meme
    if (IMAGES.meme) {
      const s = Math.max(36, Math.round(Math.min(W(),H())*0.07));
      const pad = 14;
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.drawImage(IMAGES.meme, W()-pad-s, pad, s, s);
      ctx.restore();
    }
  }

  // ---------- Background + ground ----------
  function drawGroundWithHoles() {
    doodleStroke();
    const gy = world.groundY();
    const holes = world.holes.slice().sort((a,b)=>a.x-b.x);

    // linea terreno a segmenti (con buchi)
    let start = 0;
    ctx.beginPath();
    for (const h of holes) {
      const a = Math.max(0, Math.min(W(), h.x));
      const b = Math.max(0, Math.min(W(), h.x + h.w));
      if (a > start) {
        ctx.moveTo(start, gy);
        ctx.lineTo(a, gy);
      }
      start = Math.max(start, b);
      if (start >= W()) break;
    }
    if (start < W()) {
      ctx.moveTo(start, gy);
      ctx.lineTo(W(), gy);
    }
    ctx.stroke();

    // “dentini” sul bordo buco (assurdo horror cartoon)
    ctx.save();
    ctx.globalAlpha = 0.45;
    ctx.lineWidth = Math.max(2, ctx.lineWidth*0.55);
    for (const h of holes) {
      const left = Math.max(0, Math.min(W(), h.x));
      const right = Math.max(0, Math.min(W(), h.x + h.w));
      for (let x = left; x <= right; x += 18) {
        ctx.beginPath();
        ctx.moveTo(x, gy);
        ctx.lineTo(x+6, gy+10);
        ctx.stroke();
      }
    }
    ctx.restore();

    // erbetta solo su terreno
    ctx.lineWidth *= 0.7;
    const step = Math.max(24, Math.floor(W()/30));
    for (let x=0; x<=W(); x+=step) {
      if (!groundUnderX(x)) continue;
      ctx.beginPath();
      ctx.moveTo(x, gy);
      ctx.lineTo(x+4, gy-8);
      ctx.stroke();
    }
  }

  function drawBackgroundBase() {
    // sfondo immagine (se presente)
    if (IMAGES.bg) {
      drawImageCover(IMAGES.bg, 1);
      return;
    }

    // fallback: circo horror meme (no gore)
    const g = ctx.createLinearGradient(0,0,0,H());
    g.addColorStop(0, "rgba(20, 12, 35, 1)");
    g.addColorStop(0.55, "rgba(70, 18, 60, 1)");
    g.addColorStop(1, "rgba(10, 10, 18, 1)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W(),H());

    // tende/strisce
    ctx.save();
    ctx.globalAlpha = 0.14;
    for (let x=0; x<W(); x+=44) {
      ctx.fillStyle = (Math.floor(x/44)%2===0) ? "#000" : "#fff";
      ctx.fillRect(x, 0, 22, H());
    }
    ctx.restore();

    // nebbia
    ctx.save();
    const fogA = 0.16 + Math.max(0, Math.min(1, world.fog)) * 0.22;
    ctx.globalAlpha = fogA;
    const fg = ctx.createRadialGradient(W()*0.45, H()*0.35, 10, W()*0.45, H()*0.35, Math.max(W(),H())*0.95);
    fg.addColorStop(0, "rgba(255,255,255,0.35)");
    fg.addColorStop(0.5, "rgba(255,255,255,0.10)");
    fg.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = fg;
    ctx.fillRect(0,0,W(),H());
    ctx.restore();
  }

  function drawBackground() {
    ctx.clearRect(0,0,W(),H());
    drawBackgroundBase();

    // layer horror/meme
    drawMemeWorldLayers();

    // terreno con buchi
    drawGroundWithHoles();

    // etichetta
    doodleStroke();
    const pad = 14;
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.font = `900 ${Math.max(14, Math.round(Math.min(W(),H())*0.022))}px ui-rounded, system-ui, -apple-system, sans-serif`;
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#000";
    ctx.lineWidth = Math.max(3, Math.round(Math.min(W(),H())*0.004));
    const txt = "HORROR MEME PANICORE • PORCELLINO";
    ctx.textAlign = "right";
    ctx.strokeText(txt, W()-pad, H()-pad);
    ctx.fillText(txt, W()-pad, H()-pad);
    ctx.textAlign = "left";
    ctx.restore();
  }

  // ---------- Pig render ----------
  function drawPig() {
    doodleStroke();
    const r = pig.r();
    const x = pig.x();
    const y = pig.y;

    const panic = Math.max(0, Math.min(1, (world.speed - 340) / 200));
    const glitch = Math.max(0, Math.min(1, world.glitch / 0.22));

    // aura più cattiva quando glitch
    ctx.save();
    ctx.globalAlpha = 0.12 + panic*0.16 + glitch*0.20;
    const ag = ctx.createRadialGradient(x, y, r*0.2, x, y, r*2.4);
    ag.addColorStop(0, "rgba(255, 100, 170, 0.9)");
    ag.addColorStop(0.6, "rgba(190, 120, 255, 0.25)");
    ag.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = ag;
    ctx.beginPath();
    ctx.arc(x, y, r*2.4, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // corpo
    ctx.beginPath();
    ctx.ellipse(x, y, r*1.05, r*0.85, 0, 0, Math.PI*2);
    ctx.fillStyle = "#ffd2dd";
    ctx.fill();
    ctx.stroke();

    // orecchie
    ctx.beginPath();
    ctx.ellipse(x - r*0.6, y - r*0.75, r*0.28, r*0.35, -0.4, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();
    ctx.beginPath();
    ctx.ellipse(x + r*0.6, y - r*0.75, r*0.28, r*0.35, 0.4, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // muso
    ctx.beginPath();
    ctx.roundRect(x - r*0.45, y - r*0.12, r*0.9, r*0.55, r*0.22);
    ctx.fillStyle="#fff";
    ctx.fill(); ctx.stroke();

    // narici
    ctx.fillStyle="#000";
    ctx.beginPath(); ctx.arc(x - r*0.18, y + r*0.12, Math.max(2, r*0.07), 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + r*0.18, y + r*0.12, Math.max(2, r*0.07), 0, Math.PI*2); ctx.fill();

    // occhi + bocca (più "spaventato" in glitch)
    const eyeJ = glitch*2.2;
    ctx.beginPath(); ctx.arc(x - r*0.3, y - r*0.25, Math.max(2, r*0.07 + glitch*1.2), 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + r*0.3, y - r*0.25, Math.max(2, r*0.07 + glitch*1.2), 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle="#000";
    ctx.lineWidth = Math.max(2, ctx.lineWidth*0.6);
    ctx.beginPath();
    const smileR = r*(0.22 + glitch*0.06);
    ctx.arc(x + Math.sin(world.t*18)*eyeJ, y - r*0.05, smileR, 0.1*Math.PI, 0.9*Math.PI);
    ctx.stroke();

    // dentino meme (solo grafico, cartoon)
    if (glitch > 0.05) {
      ctx.save();
      ctx.globalAlpha = 0.75*glitch;
      ctx.fillStyle="#fff";
      ctx.strokeStyle="#000";
      ctx.lineWidth = Math.max(2, ctx.lineWidth*0.6);
      ctx.beginPath();
      ctx.moveTo(x - r*0.05, y + r*0.10);
      ctx.lineTo(x + r*0.02, y + r*0.18);
      ctx.lineTo(x + r*0.08, y + r*0.10);
      ctx.closePath();
      ctx.fill(); ctx.stroke();
      ctx.restore();
    }
  }

  // ---------- Collision ----------
  function hit(a, bx, by, br) {
    const dx = a.x - bx;
    const dy = a.y - by;
    const rr = a.r + br;
    return (dx*dx + dy*dy) <= rr*rr;
  }

  // ---------- Input ----------
  function jump() {
    if (world.state === "ready") {
      world.state = "play";
      beep(520, 0.05, "square", 0.02);
      return;
    }
    if (world.state === "over") {
      reset();
      beep(520, 0.05, "square", 0.02);
      return;
    }
    if (world.state !== "play") return;

    if (pig.onGround) {
      pig.vy = -Math.max(520, H()*0.65);
      pig.onGround = false;
      beep(380, 0.05, "sine", 0.03);
    }
  }

  addEventListener("pointerdown", (e) => { e.preventDefault(); jump(); }, { passive:false });
  addEventListener("keydown", (e) => { if (e.code==="Space" || e.code==="ArrowUp") jump(); });

  // ---------- Loop ----------
  let last = performance.now();

  function update(dt) {
    world.t += dt;

    // decay fx
    world.shake = Math.max(0, world.shake - dt);
    world.glitch = Math.max(0, world.glitch - dt);
    world.invert = Math.max(0, world.invert - dt);
    world.fog = 0.18 + Math.sin(world.t*0.6)*0.05;

    const gy = world.groundY();

    // update meme world
    updateMemeWorld(dt);

    // pig physics
    const g = Math.max(1200, H()*1.6);
    pig.vy += g * dt;
    pig.y += pig.vy * dt;

    const px = pig.x();
    const targetY = gy - pig.r();
    const hasGround = groundUnderX(px);

    if (pig.onGround && !hasGround) {
      pig.onGround = false;
      pig.vy = Math.max(0, pig.vy);
    }

    if (pig.y >= targetY && hasGround) {
      pig.y = targetY;
      pig.vy = 0;
      pig.onGround = true;
    }

    // caduta => game over
    if (!pig.onGround && pig.y - pig.r() > H() + 30) {
      world.state = "over";
      beep(120, 0.12, "sawtooth", 0.05);
      world.best = Math.max(world.best, Math.floor(world.score));
      localStorage.setItem("pig_best", String(world.best));
      return;
    }

    if (world.state !== "play") return;

    // difficulty
    world.speed = Math.min(560, world.speed + 8*dt);

    // buchi
    updateHoles(dt);

    // spawn items
    world.nextSpawn -= dt;
    if (world.nextSpawn <= 0) {
      spawnItem();
      world.nextSpawn = rand(world.spawnMin, world.spawnMax);
    }

    // items move + collision
    for (const it of items) {
      it.vx = -world.speed;
      it.x += it.vx * dt;

      if (!it.hit) {
        const pigPos = { x: pig.x(), y: pig.y, r: pig.r()*0.9 };
        if (hit(pigPos, it.x, it.y, it.r*0.95)) {
          it.hit = true;

          if (it.type === "bong") {
            world.score += 2;
            beep(740, 0.06, "triangle", 0.03);
          } else if (it.type === "cuffs") {
            world.score += 1;
            beep(660, 0.05, "triangle", 0.028);
          } else {
            // CLOWN BOO: penalità + glitch assurdo
            world.score = Math.max(0, world.score - 2);
            booChord();
            world.shake = 0.22;
            world.glitch = 0.22;
            world.invert = 0.12;
          }
        }
      }
    }

    // cleanup items
    for (let i=items.length-1; i>=0; i--) {
      if (items[i].x < -items[i].r - 40 || items[i].hit) items.splice(i,1);
    }
  }

  function centerText(text, y, scale=1.0) {
    doodleStroke();
    const size = Math.max(20, Math.round(Math.min(W(),H())*0.045*scale));
    ctx.font = `900 ${size}px ui-rounded, system-ui, -apple-system, sans-serif`;
    ctx.textAlign = "center";
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#000";
    ctx.lineWidth = Math.max(3, Math.round(Math.min(W(),H())*0.004));
    ctx.strokeText(text, W()/2, y);
    ctx.fillText(text, W()/2, y);
    ctx.textAlign = "left";
  }

  function drawOverlayText() {
    doodleStroke();
    ctx.font = `700 ${Math.max(18, Math.round(Math.min(W(),H())*0.03))}px ui-rounded, system-ui, -apple-system, sans-serif`;
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#000";
    ctx.lineWidth = Math.max(3, Math.round(Math.min(W(),H())*0.004));

    const pad = 14;
    const scoreTxt = `★ ${Math.floor(world.score)}`;
    ctx.strokeText(scoreTxt, pad, pad + 22);
    ctx.fillText(scoreTxt, pad, pad + 22);

    if (world.state === "ready") {
      centerText("TOCCA PER SALTARE", H()*0.44, 1.15);
      centerText("prendi bong/manette • evita i clown BOO", H()*0.44 + 34, 0.76);
      centerText("evita i buchi o cadi nel VUOTO ASSURDO", H()*0.44 + 62, 0.68);
    }
    if (world.state === "over") {
      centerText("CADUTO NEL BUCO!", H()*0.43, 1.2);
      centerText(`punteggio: ${Math.floor(world.score)}  |  best: ${world.best}`, H()*0.43 + 34, 0.8);
      centerText("tocca per ricominciare", H()*0.43 + 64, 0.75);
    }
  }

  function render() {
    // camera shake
    let dx=0, dy=0;
    if (world.shake > 0) {
      const k = world.shake / 0.22;
      dx = rand(-12, 12) * k;
      dy = rand(-8, 8) * k;
    }

    // glitch slices (semplice)
    const glitch = Math.max(0, Math.min(1, world.glitch / 0.22));
    const invert = Math.max(0, Math.min(1, world.invert / 0.12));

    ctx.save();
    ctx.translate(dx, dy);

    drawBackground();
    for (const it of items) drawItem(it);
    drawPig();
    drawOverlayText();

    // invert flash (assurdo)
    if (invert > 0.01) {
      ctx.save();
      ctx.globalAlpha = 0.28 * invert;
      ctx.globalCompositeOperation = "difference";
      ctx.fillStyle = "#fff";
      ctx.fillRect(-dx, -dy, W(), H());
      ctx.restore();
    }

    // glitch stripes overlay
    if (glitch > 0.01) {
      ctx.save();
      ctx.globalAlpha = 0.20 * glitch;
      ctx.fillStyle = "#fff";
      for (let i=0;i<10;i++){
        const y = rand(0, H());
        const h = rand(6, 18);
        ctx.fillRect(-dx, y, W(), h);
      }
      ctx.restore();
    }

    ctx.restore();
  }

  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  // ---------- Boot: carica immagini ----------
  (async () => {
    IMAGES.bg = await loadImage(ASSETS.bgSrc);
    IMAGES.world = await loadImage(ASSETS.worldSrc);
    IMAGES.meme = await loadImage(ASSETS.memeSrc);

    IMAGES.bong = await loadImage(ASSETS.bongSrc);
    IMAGES.cuffs = await loadImage(ASSETS.cuffsSrc);
    IMAGES.clown = await loadImage(ASSETS.clownSrc);

    reset();
    requestAnimationFrame(loop);
  })();

})();
</script>
</body>
</html>
