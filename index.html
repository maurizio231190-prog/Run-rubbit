<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Cascata POP — Runner</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0b10; overflow:hidden; }
    canvas { display:block; width:100dvw; height:100dvh; touch-action:none; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  const DPR = Math.min(2, window.devicePixelRatio || 1);
  function resize(){
    const vw = document.documentElement.clientWidth;
    const vh = document.documentElement.clientHeight;
    canvas.width = Math.floor(vw * DPR);
    canvas.height = Math.floor(vh * DPR);
  }
  addEventListener('resize', resize);
  resize();

  // ===== helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a+Math.random()*(b-a);

  // ===== minimal audio (opzionale)
  class Snd {
    constructor(){ this.ctx=null; this.g=null; this.cool=0; }
    ensure(){
      if(this.ctx) return;
      const AC = window.AudioContext||window.webkitAudioContext;
      if(!AC) return;
      this.ctx=new AC();
      this.g=this.ctx.createGain();
      this.g.gain.value=0.18;
      this.g.connect(this.ctx.destination);
    }
    beep(f=440,d=0.08,g=0.06,type='sine'){
      if(!this.ctx) return;
      const t0=this.ctx.currentTime;
      const o=this.ctx.createOscillator();
      const ga=this.ctx.createGain();
      o.type=type;
      o.frequency.setValueAtTime(f,t0);
      ga.gain.setValueAtTime(0.0001,t0);
      ga.gain.exponentialRampToValueAtTime(g,t0+0.01);
      ga.gain.exponentialRampToValueAtTime(0.0001,t0+d);
      o.connect(ga); ga.connect(this.g);
      o.start(t0); o.stop(t0+d+0.02);
    }
    star(){ this.beep(rand(520,780),0.07,0.06,'sine'); this.beep(rand(980,1300),0.05,0.03,'triangle'); }
    hit(){ this.beep(rand(140,190),0.14,0.07,'square'); }
  }
  const S = new Snd();

  // ===== palette (senza contorni)
  const PAL = {
    bgTop:'#0b0b10',
    bgBot:'#131322',
    glow1:'rgba(255,120,60,0.22)',
    glow2:'rgba(255,210,120,0.12)',
    ground:'#1b1b2d',
    ground2:'#22223a',
    bunny:'#f2f2f7',
    bunny2:'#d9d9e6',
    star:'#ffe37a',
    bad:'#ff6a6a',
    good:'#8dffb1'
  };

  // ===== game state
  const G = {
    t:0,
    last: performance.now(),
    state:'idle', // idle | play | over
    score:0,
    lives:3,

    // world speed
    speed: 520 * DPR,
    speedUp: 6 * DPR,

    // ground
    groundY: 0,
    groundH: 0,
    groundScroll: 0,

    // player (coniglio)
    p: { x:0, y:0, w:0, h:0, vy:0, onGround:true, coyote:0, jumpBuf:0, tail:22 },

    // entities
    obs: [],
    stars: [],
    spawnObs: 0,
    spawnStar: 0
  };

  function reset(){
    const W=canvas.width, H=canvas.height;
    G.t=0;
    G.state='idle';
    G.score=0;
    G.lives=3;
    G.speed = 520 * DPR;
    G.groundH = Math.max(70*DPR, H*0.16);
    G.groundY = H - G.groundH;
    G.groundScroll = 0;

    G.p.w = 78*DPR;
    G.p.h = 78*DPR;
    G.p.x = W * 0.22;
    G.p.y = G.groundY - G.p.h;
    G.p.vy = 0;
    G.p.onGround = true;
    G.p.coyote = 0;
    G.p.jumpBuf = 0;
    G.p.tail = 22;

    G.obs.length=0;
    G.stars.length=0;
    G.spawnObs = 0.8;
    G.spawnStar = 0.35;
  }
  reset();

  // ===== input: tap = jump
  function requestJump(){
    // buffer: se tocchi poco prima di atterrare, salta appena tocchi terra
    G.p.jumpBuf = 0.14;
  }
  canvas.addEventListener('pointerdown', (e)=>{
    S.ensure();
    if(G.state!=='play'){
      reset();
      G.state='play';
      return;
    }
    requestJump();
  });

  // ===== physics
  function jump(){
    const p=G.p;
    // salto “morbido”
    p.vy = -820 * DPR;
    p.onGround=false;
    p.coyote=0;
    p.jumpBuf=0;
  }

  // ===== spawn
  function spawnObstacle(){
    const W=canvas.width;
    const w = rand(56,82)*DPR;
    const h = rand(70,96)*DPR;
    G.obs.push({
      x: W + w,
      y: G.groundY - h,
      w,h,
      // variante “maestra cattiva” (rosso)
      type:'bad',
      bob: rand(0, Math.PI*2)
    });
  }
  function spawnStar(){
    const W=canvas.width;
    const r = rand(16,22)*DPR;
    const yMin = G.groundY - 220*DPR;
    const yMax = G.groundY - 110*DPR;
    G.stars.push({
      x: W + r*2,
      y: rand(yMin,yMax),
      r,
      spin: rand(0, Math.PI*2)
    });
  }

  // ===== collisions
  function aabb(ax,ay,aw,ah,bx,by,bw,bh){
    return !(ax+aw<bx || ax>bx+bw || ay+ah<by || ay>by+bh);
  }

  // ===== render helpers (no lines)
  function bg(){
    const W=canvas.width, H=canvas.height;
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, PAL.bgTop);
    g.addColorStop(1, PAL.bgBot);
    ctx.fillStyle=g;
    ctx.fillRect(0,0,W,H);

    // glow dietro (fuoco “alle spalle” ma fermo)
    ctx.globalAlpha=1;
    ctx.fillStyle = PAL.glow1;
    ctx.beginPath();
    ctx.ellipse(W*0.58, H*0.58, W*0.55, H*0.26, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = PAL.glow2;
    ctx.beginPath();
    ctx.ellipse(W*0.62, H*0.62, W*0.62, H*0.30, 0, 0, Math.PI*2);
    ctx.fill();

    // piccole particelle (parallasse finta)
    const n=22;
    for(let i=0;i<n;i++){
      const x = (i*97 + (G.t*40)) % (W+120) - 60;
      const y = (i*53) % (H*0.65);
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.ellipse(x, y, 2.2*DPR, 2.2*DPR, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha=1;
  }

  function ground(){
    const W=canvas.width, H=canvas.height;
    // base
    ctx.fillStyle = PAL.ground;
    ctx.fillRect(0, G.groundY, W, G.groundH);

    // stripes che scorrono = “sensazione corsa”
    const stripeW = 64*DPR;
    const gap = 26*DPR;
    const y = G.groundY + G.groundH*0.22;
    const h = G.groundH*0.18;

    const off = (G.groundScroll % (stripeW+gap));
    for(let x=-off; x<W+stripeW; x += (stripeW+gap)){
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = PAL.ground2;
      ctx.beginPath();
      ctx.roundRect(x, y, stripeW, h, 18*DPR);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // linea “horizon” soft
    const g = ctx.createLinearGradient(0, G.groundY-18*DPR, 0, G.groundY+18*DPR);
    g.addColorStop(0,'rgba(255,255,255,0)');
    g.addColorStop(1,'rgba(255,255,255,0.06)');
    ctx.fillStyle=g;
    ctx.fillRect(0, G.groundY-18*DPR, W, 36*DPR);
  }

  function drawBunny(){
    const p=G.p;
    const x=p.x, y=p.y, w=p.w, h=p.h;

    // ombra
    ctx.globalAlpha=0.18;
    ctx.fillStyle='black';
    ctx.beginPath();
    ctx.ellipse(x+w*0.52, G.groundY + 10*DPR, w*0.40, 10*DPR, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha=1;

    // coda “gonfia”
    const tail = p.tail; // 0..100-ish
    const tailR = (w*0.13) + tail*0.09*DPR;
    ctx.fillStyle = PAL.bunny2;
    ctx.beginPath();
    ctx.ellipse(x+w*0.88, y+h*0.58, tailR, tailR*0.92, 0, 0, Math.PI*2);
    ctx.fill();

    // corpo
    ctx.fillStyle = PAL.bunny;
    ctx.beginPath();
    ctx.ellipse(x+w*0.52, y+h*0.58, w*0.36, h*0.30, 0, 0, Math.PI*2);
    ctx.fill();

    // testa
    ctx.beginPath();
    ctx.ellipse(x+w*0.48, y+h*0.34, w*0.30, h*0.26, 0, 0, Math.PI*2);
    ctx.fill();

    // orecchie (piccolo “bop” mentre corre)
    const bob = 1 + 0.03*Math.sin(G.t*10);
    ctx.beginPath();
    ctx.ellipse(x+w*0.38, y+h*0.08, w*0.10, h*0.22*bob, -0.22, 0, Math.PI*2);
    ctx.ellipse(x+w*0.56, y+h*0.08, w*0.10, h*0.22*bob,  0.22, 0, Math.PI*2);
    ctx.fill();

    // occhi (puntini kawaii)
    ctx.fillStyle = 'rgba(0,0,0,0.78)';
    ctx.beginPath(); ctx.ellipse(x+w*0.40, y+h*0.33, w*0.03, h*0.05, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(x+w*0.54, y+h*0.33, w*0.03, h*0.05, 0, 0, Math.PI*2); ctx.fill();

    // naso
    ctx.fillStyle = 'rgba(0,0,0,0.62)';
    ctx.beginPath(); ctx.ellipse(x+w*0.47, y+h*0.42, w*0.02, h*0.02, 0, 0, Math.PI*2); ctx.fill();
  }

  function drawStar(s){
    const pulse = 0.5 + 0.5*Math.sin(s.spin*3);
    const r = s.r * (1 + pulse*0.08);
    ctx.fillStyle = PAL.star;
    ctx.beginPath();
    const spikes=5;
    for(let i=0;i<spikes*2;i++){
      const a = (i/(spikes*2))*Math.PI*2 - Math.PI/2;
      const rr = (i%2===0)? r : r*0.45;
      const px = s.x + Math.cos(a)*rr;
      const py = s.y + Math.sin(a)*rr;
      if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath();
    ctx.fill();
  }

  function drawBad(o){
    // “maestra cattiva” super semplificata e morbida (rosso)
    ctx.fillStyle = PAL.bad;
    ctx.beginPath();
    ctx.roundRect(o.x, o.y, o.w, o.h, 18*DPR);
    ctx.fill();

    // bocca “urlo” (solo un ovalino scuro)
    ctx.fillStyle = 'rgba(0,0,0,0.28)';
    ctx.beginPath();
    ctx.ellipse(o.x+o.w*0.55, o.y+o.h*0.58, o.w*0.12, o.h*0.12, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // ===== update
  function update(dt){
    const W=canvas.width, H=canvas.height;
    G.t += dt;

    // accelera piano
    G.speed = Math.min(920*DPR, G.speed + G.speedUp*dt);

    // ground scroll
    G.groundScroll += G.speed * dt;

    // player physics
    const p=G.p;
    const gravity = 2100 * DPR;
    p.jumpBuf = Math.max(0, p.jumpBuf - dt);

    // coyote time
    if(p.onGround) p.coyote = 0.10;
    else p.coyote = Math.max(0, p.coyote - dt);

    // jump trigger
    if(p.jumpBuf>0 && p.coyote>0){
      jump();
    }

    // integrate
    p.vy += gravity * dt;
    p.y += p.vy * dt;

    // ground collision
    const groundTop = G.groundY - p.h;
    if(p.y >= groundTop){
      p.y = groundTop;
      p.vy = 0;
      p.onGround = true;
    } else {
      p.onGround = false;
    }

    // spawn timers
    G.spawnObs -= dt;
    if(G.spawnObs<=0){
      spawnObstacle();
      G.spawnObs = rand(1.05, 1.65) / (0.85 + G.difficulty());
    }

    G.spawnStar -= dt;
    if(G.spawnStar<=0){
      spawnStar();
      G.spawnStar = rand(0.35, 0.75);
    }

    // move obstacles
    for(let i=G.obs.length-1;i>=0;i--){
      const o=G.obs[i];
      o.x -= G.speed * dt;
      if(o.x < -o.w-40*DPR){ G.obs.splice(i,1); continue; }

      // collision
      const hit = aabb(p.x+p.w*0.18, p.y+p.h*0.18, p.w*0.64, p.h*0.70, o.x, o.y, o.w, o.h);
      if(hit){
        G.obs.splice(i,1);
        G.lives--;
        S.hit();
        // penalità: coda si sgonfia un po'
        p.tail = Math.max(0, p.tail - 10);
        if(G.lives<=0){
          G.state='over';
        }
      }
    }

    // move stars
    for(let i=G.stars.length-1;i>=0;i--){
      const s=G.stars[i];
      s.x -= (G.speed*1.02) * dt;
      s.spin += dt*2.2;
      if(s.x < -s.r-40*DPR){ G.stars.splice(i,1); continue; }

      // collision
      const hit = aabb(p.x+p.w*0.18, p.y+p.h*0.18, p.w*0.64, p.h*0.70, s.x-s.r, s.y-s.r, s.r*2, s.r*2);
      if(hit){
        G.stars.splice(i,1);
        G.score++;
        S.star();
        // reward: coda cresce (stile “scelte”/progressione)
        p.tail = Math.min(100, p.tail + 6);
      }
    }
  }

  // difficoltà “soft” (0..1)
  G.difficulty = () => clamp(G.t/70, 0, 1);

  // ===== render HUD
  function hud(){
    const W=canvas.width, H=canvas.height;
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.font = `${Math.floor(16*DPR)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign='left';
    ctx.textBaseline='top';
    ctx.fillText(`⭐ ${G.score}`, 12*DPR, 10*DPR);
    ctx.fillText(`❤️ ${G.lives}`, 12*DPR, 30*DPR);

    // mini barra “coda”
    const bx = 12*DPR, by = 52*DPR, bw = 120*DPR, bh = 8*DPR;
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = 'white';
    ctx.beginPath(); ctx.roundRect(bx,by,bw,bh,10*DPR); ctx.fill();
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = PAL.bunny2;
    ctx.beginPath(); ctx.roundRect(bx,by,bw*(clamp(G.p.tail,0,100)/100),bh,10*DPR); ctx.fill();
    ctx.restore();

    if(G.state!=='play'){
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.88)';
      ctx.font = `${Math.floor(22*DPR)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      const msg = (G.state==='over') ? 'RIPROVA: TOCCA PER RIPARTIRE' : 'TOCCA PER INIZIARE (SALTO)';
      ctx.fillText(msg, W/2, H*0.30);
      ctx.restore();
    }
  }

  // ===== main loop
  function frame(now){
    const dt = Math.min(0.033, (now - G.last)/1000);
    G.last = now;

    // start/restart logic
    if(G.state==='idle' || G.state==='over'){
      // resta fermo finché non tocchi
    } else {
      update(dt);
    }

    // draw
    bg();
    ground();
    // stars behind obstacles? più carino: stars sopra, obstacles davanti
    for(const s of G.stars) drawStar(s);
    for(const o of G.obs) drawBad(o);
    drawBunny();
    hud();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // touch/click in idle/over: start
  canvas.addEventListener('pointerdown', ()=>{
    if(G.state==='idle' || G.state==='over'){
      reset();
      G.state='play';
    }
  });

})();
</script>
</body>
</html>
