<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Cascata POP - Debug Background Fix</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; touch-action:none; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
/**
 * Perché vedevi nero:
 * - l'immagine NON viene caricata (nome/percorso/commit/pages)
 * Questo file:
 * - prova vari percorsi corretti (anche con base path GitHub Pages)
 * - se fallisce, mostra a schermo gli URL provati e l'errore (404 ecc.)
 */

// ========= CANVAS =========
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width  = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

// ========= UTILS =========
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;
const easeIn = (t)=>t*t;

// ========= GAME CONFIG (minimo) =========
const LANES = 5;
const cfg = {
  topY: 0.20,
  bottomY: 0.90,
  topSpread: 0.18,
  bottomLeft: 0.12,
  bottomRight: 0.88,

  spawnEveryMs: 650,
  baseSpeed: 0.42,
  speedRamp: 0.00006,
  goodChance: 0.62,
  lives: 3,

  hitT: 0.93,
  hitWindow: 0.055
};

function laneX(laneIndex, tNorm, w) {
  const r = (LANES===1) ? 0.5 : laneIndex/(LANES-1);
  const topCenter = 0.5;
  const topLeft  = topCenter - cfg.topSpread/2;
  const topRight = topCenter + cfg.topSpread/2;

  const xTop = lerp(topLeft*w, topRight*w, r);
  const xBot = lerp(cfg.bottomLeft*w, cfg.bottomRight*w, r);
  return lerp(xTop, xBot, tNorm);
}
function yFromT(tNorm, h) {
  const t = easeIn(clamp(tNorm, 0, 1));
  return lerp(cfg.topY*h, cfg.bottomY*h, t);
}
function scaleFromT(tNorm) {
  return lerp(0.35, 1.05, clamp(tNorm,0,1));
}
function nearestLaneAtBottom(x, w) {
  let best = 0, bestD = Infinity;
  for (let i=0;i<LANES;i++) {
    const lx = laneX(i, 1, w);
    const d = Math.abs(x - lx);
    if (d < bestD) { bestD = d; best = i; }
  }
  return best;
}

// ========= BACKGROUND (FIX ROBUSTO) =========
// Base dir corretto anche su GitHub Pages (con /nomeRepo/ dentro)
const BASE_DIR = new URL(".", window.location.href).href;

// Percorsi "probabili" (relativi alla cartella dell'index.html)
const BG_CANDIDATES = [
  "bg.png",
  "bg.jpg",
  "bg.jpeg",
  "assets/bg.png",
  "assets/bg.jpg",
  "img/bg.png",
  "img/bg.jpg",
];

const bgImg = new Image();
let bgReady = false;

let bgChosenUrl = "";
let bgLoading = true;
let bgErrors = []; // {url, status?, error?}
let bgObjectUrl = ""; // per blob URL, se usiamo fetch

async function tryFetchAsImage(url) {
  // Usiamo fetch così sappiamo: 404? 403? ecc.
  // NOTA: se apri in file://, fetch può fallire -> te lo scrive a schermo.
  try {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) {
      return { ok:false, status: res.status };
    }
    const blob = await res.blob();
    const objUrl = URL.createObjectURL(blob);

    await new Promise((resolve, reject) => {
      bgImg.onload = resolve;
      bgImg.onerror = reject;
      bgImg.src = objUrl;
    });

    bgObjectUrl = objUrl;
    return { ok:true };
  } catch (e) {
    return { ok:false, error: String(e) };
  }
}

async function loadBackground() {
  bgLoading = true;
  bgReady = false;
  bgErrors = [];

  for (const rel of BG_CANDIDATES) {
    const abs = new URL(rel, BASE_DIR).href;
    const r = await tryFetchAsImage(abs);
    if (r.ok) {
      bgChosenUrl = abs;
      bgReady = true;
      bgLoading = false;
      return;
    }
    bgErrors.push({ url: abs, ...r });
  }

  bgLoading = false;
}
loadBackground();

// ========= GAME STATE (minimo) =========
let started = false;
let lastTs = 0;
let elapsed = 0;

const state = {
  score: 0,
  lives: cfg.lives,
  playerLane: 2,
  playerSkin: "bunny",
  obstacles: [],
  nextSpawn: 0
};

function resetGame() {
  state.score = 0;
  state.lives = cfg.lives;
  state.playerLane = 2;
  state.obstacles = [];
  elapsed = 0;
  lastTs = 0;
  state.nextSpawn = 0;
}

// ========= DRAW (semplice) =========
function drawKawaiiFace(x, y, r) {
  ctx.fillStyle = "rgba(0,0,0,0.85)";
  ctx.beginPath(); ctx.arc(x - r*0.35, y - r*0.10, r*0.10, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + r*0.35, y - r*0.10, r*0.10, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.beginPath(); ctx.arc(x - r*0.32, y - r*0.14, r*0.04, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + r*0.38, y - r*0.14, r*0.04, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = "rgba(0,0,0,0.75)";
  ctx.lineWidth = Math.max(1, r*0.06);
  ctx.beginPath();
  ctx.arc(x, y + r*0.08, r*0.18, 0.15*Math.PI, 0.85*Math.PI);
  ctx.stroke();
}

function drawPlayer(x, y, s, skin) {
  const r = 18 * s;
  ctx.save();
  ctx.translate(x, y);

  if (skin === "boy" || skin === "girl") {
    ctx.fillStyle = "rgba(255,240,220,0.95)";
    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = (skin==="girl") ? "rgba(230,200,80,0.95)" : "rgba(120,70,30,0.95)";
    ctx.beginPath(); ctx.arc(0, -r*0.2, r*1.05, Math.PI, 0); ctx.fill();

    ctx.fillStyle = "rgba(60,220,140,0.95)";
    ctx.beginPath(); ctx.arc(-r*1.05, 0, r*0.35, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( r*1.05, 0, r*0.35, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle = "rgba(30,30,30,0.7)";
    ctx.lineWidth = Math.max(2, r*0.12);
    ctx.beginPath(); ctx.arc(0, -r*0.65, r*1.1, Math.PI*1.05, Math.PI*1.95); ctx.stroke();

    drawKawaiiFace(0, 2, r*0.95);
  } else {
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(-r*0.55, -r*1.25, r*0.35, r*0.75, -0.15, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse( r*0.55, -r*1.25, r*0.35, r*0.75,  0.15, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = "rgba(255,170,190,0.85)";
    ctx.beginPath(); ctx.ellipse(-r*0.55, -r*1.22, r*0.18, r*0.55, -0.15, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse( r*0.55, -r*1.22, r*0.18, r*0.55,  0.15, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = "rgba(80,180,255,0.95)";
    ctx.beginPath(); ctx.arc(-r*1.00, 0, r*0.32, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( r*1.00, 0, r*0.32, 0, Math.PI*2); ctx.fill();

    drawKawaiiFace(0, 2, r*0.95);
  }

  ctx.restore();
}

function roundRect(x, y, w, h, r) {
  r = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

function drawGood(x, y, s) {
  const r = 22 * s;
  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = "rgba(255,120,170,0.55)";
  ctx.beginPath(); ctx.arc(x - r*0.5, y + r*0.15, r*0.22, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + r*0.5, y + r*0.15, r*0.22, 0, Math.PI*2); ctx.fill();
  drawKawaiiFace(x, y, r);
}

function drawBad(x, y, s) {
  const size = 44 * s;
  const rr = 10 * s;

  ctx.fillStyle = "rgba(255,200,70,0.95)";
  roundRect(x - size/2, y - size/2, size, size, rr);
  ctx.fill();

  ctx.fillStyle = "rgba(20,20,20,0.85)";
  roundRect(x - size*0.35, y - size*0.68, size*0.7, size*0.22, 6*s);
  ctx.fill();

  ctx.strokeStyle = "rgba(0,0,0,0.8)";
  ctx.lineWidth = Math.max(2, 3*s);
  ctx.beginPath();
  ctx.moveTo(x - size*0.22, y - size*0.12);
  ctx.lineTo(x - size*0.02, y - size*0.22);
  ctx.moveTo(x + size*0.22, y - size*0.12);
  ctx.lineTo(x + size*0.02, y - size*0.22);
  ctx.stroke();

  ctx.fillStyle = "rgba(0,0,0,0.85)";
  ctx.beginPath(); ctx.arc(x - size*0.16, y - size*0.02, 4*s, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + size*0.16, y - size*0.02, 4*s, 0, Math.PI*2); ctx.fill();

  ctx.strokeStyle = "rgba(120,0,0,0.85)";
  ctx.lineWidth = Math.max(2, 4*s);
  ctx.beginPath();
  ctx.moveTo(x - size*0.12, y + size*0.15);
  ctx.lineTo(x + size*0.12, y + size*0.15);
  ctx.stroke();

  ctx.fillStyle = "rgba(40,170,255,0.9)";
  ctx.beginPath();
  ctx.moveTo(x + size*0.30, y - size*0.05);
  ctx.lineTo(x + size*0.55, y - size*0.16);
  ctx.lineTo(x + size*0.55, y + size*0.06);
  ctx.closePath();
  ctx.fill();
}

// ========= SPAWN/UPDATE =========
function spawnObstacle() {
  const lane = Math.floor(Math.random() * LANES);
  const isGood = Math.random() < cfg.goodChance;
  state.obstacles.push({ lane, t: 0, kind: isGood ? "good" : "bad", taken: false });
}

function update(dt) {
  elapsed += dt;

  state.nextSpawn -= dt*1000;
  if (state.nextSpawn <= 0) {
    spawnObstacle();
    const jitter = (Math.random()*140 - 70);
    state.nextSpawn = Math.max(260, cfg.spawnEveryMs + jitter);
  }

  const speed = cfg.baseSpeed + elapsed * cfg.speedRamp;
  for (const o of state.obstacles) o.t += dt * speed;

  for (const o of state.obstacles) {
    if (o.taken) continue;
    const near = Math.abs(o.t - cfg.hitT) <= cfg.hitWindow;
    if (!near) continue;

    if (o.lane === state.playerLane) {
      o.taken = true;
      if (o.kind === "good") state.score += 10;
      else {
        state.lives -= 1;
        if (state.lives <= 0) started = false;
      }
    }
  }

  state.obstacles = state.obstacles.filter(o => o.t < 1.15 && !o.taken);
}

// ========= RENDER =========
function drawBgCover() {
  const w = innerWidth, h = innerHeight;

  if (bgReady) {
    const iw = bgImg.naturalWidth, ih = bgImg.naturalHeight;
    const s = Math.max(w/iw, h/ih);
    const dw = iw*s, dh = ih*s;
    const dx = (w - dw)/2;
    const dy = (h - dh)/2;
    ctx.drawImage(bgImg, dx, dy, dw, dh);
    return;
  }

  // Non lasciamo "nero muto": scriviamo il motivo
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,w,h);

  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillText(bgLoading ? "Caricamento sfondo..." : "Sfondo NON caricato.", 14, 28);

  ctx.font = "13px system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.fillText("URL pagina: " + window.location.href, 14, 50);
  ctx.fillText("Cartella base: " + BASE_DIR, 14, 68);

  if (!bgLoading) {
    ctx.fillStyle = "rgba(255,120,120,0.95)";
    ctx.fillText("Cause tipiche: bg.png NON esiste / nome sbagliato / file non committato / Pages da cartella diversa.", 14, 90);

    ctx.fillStyle = "rgba(255,255,255,0.88)";
    let y = 114;
    ctx.fillText("Ho provato questi URL:", 14, y); y += 18;

    for (const e of bgErrors.slice(0, 10)) {
      const msg = e.status ? `status ${e.status}` : (e.error ? e.error : "errore");
      ctx.fillText("• " + e.url + "  →  " + msg, 14, y);
      y += 16;
      if (y > h - 24) break;
    }
  }
}

function drawHud() {
  ctx.save();
  ctx.globalAlpha = 0.75;
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.fillRect(10, 10, 210, 58);
  ctx.globalAlpha = 1;
  ctx.fillStyle = "white";
  ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillText(`Punti: ${state.score}`, 22, 34);
  ctx.fillText(`Vite: ${"❤".repeat(Math.max(0,state.lives))}`, 22, 54);
  ctx.restore();
}

function render() {
  const w = innerWidth, h = innerHeight;
  ctx.clearRect(0,0,w,h);

  drawBgCover();

  for (const o of state.obstacles) {
    const x = laneX(o.lane, o.t, w);
    const y = yFromT(o.t, h);
    const s = scaleFromT(o.t);
    if (o.kind === "good") drawGood(x, y, s);
    else drawBad(x, y, s);
  }

  const px = laneX(state.playerLane, 1, w);
  const py = yFromT(1, h);
  drawPlayer(px, py, 1.0, state.playerSkin);

  drawHud();

  if (!started) {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(0,0,w,h);
    ctx.fillStyle = "white";
    ctx.font = "20px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.textAlign = "center";
    ctx.fillText("TOCCA PER INIZIARE (1/2/3 cambia personaggio)", w/2, h*0.45);
    ctx.restore();
  }
}

// ========= LOOP =========
function loop(ts) {
  if (!lastTs) lastTs = ts;
  const dt = Math.min(0.033, (ts - lastTs)/1000);
  lastTs = ts;

  if (started) update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ========= INPUT =========
let pointerDown = false;

function startOrRestart() {
  if (state.lives <= 0) resetGame();
  started = true;
}

canvas.addEventListener("pointerdown", (e) => {
  pointerDown = true;
  canvas.setPointerCapture?.(e.pointerId);
  if (!started) startOrRestart();
  state.playerLane = nearestLaneAtBottom(e.clientX, innerWidth);
});
canvas.addEventListener("pointermove", (e) => {
  if (!pointerDown || !started) return;
  state.playerLane = nearestLaneAtBottom(e.clientX, innerWidth);
});
canvas.addEventListener("pointerup", () => pointerDown = false);
canvas.addEventListener("pointercancel", () => pointerDown = false);

addEventListener("keydown", (e) => {
  if (e.key === "ArrowLeft") state.playerLane = clamp(state.playerLane - 1, 0, LANES-1);
  if (e.key === "ArrowRight") state.playerLane = clamp(state.playerLane + 1, 0, LANES-1);
  if (e.key === "1") state.playerSkin = "boy";
  if (e.key === "2") state.playerSkin = "girl";
  if (e.key === "3") state.playerSkin = "bunny";
});
</script>
</body>
</html>
